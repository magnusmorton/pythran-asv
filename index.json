{"project": "pythran", "project_url": "https://pythran.readthedocs.org/", "show_commit_url": "#", "hash_length": 8, "revision_to_hash": {"3517": "9ce6deec71b464fc0fd3df3ba1f5338e3d49b75e", "3541": "771c3a0601b0bd96ad458d2dd3fe4e640edc4f0b", "3663": "b5d3b6db626d4a3d0c7d149e3af8d135a561d839", "3669": "d3a73492e1c36004a33f20794ef1a1788819ddc6", "3783": "6f9fc994d34fc0ed328a199ee6fec8499049a7f8", "3791": "e6c557c1d2ac9014b58847c81b489ce3953ebe5c", "3796": "8e17a11c7dbf00f1c5577f25fbd475d07c08b1c2", "3799": "8fdb144fe1fcef464e1e41f4c178126e174a9c2d", "3800": "05d387b1354c017855c3c38d6023af4ce01fbb3a", "3807": "036c368b127d0cff64a27a6412baa08df3dbf156", "3809": "ed86b183edd1e32ccfead784dd342535587da04c", "3813": "42554d8009a3bd04e2c9efa8459a05ae7b4420cf", "3815": "7ac6f671ffeca043afcc11fb8da7569003ce738e", "3816": "c622beb786aa648c779444e2e5ba81450ccccb81", "3822": "f5d170f5a5fc9554e1476dafa4928683d24d646c", "3823": "4eed0fe88a96a5e7447ed27c53010a4fbf237d0d", "3825": "b966fe6c6aba34474880e2a086373cf6ee91345e", "3830": "be5b8a500ac41231277b1631e3568517ca2d01cc", "3831": "62f5577f1d3e340124e49f404d7214932b6c59ed", "3845": "953cab318383c2546bf65cadfd4428f51245df6f", "3848": "85ed61a1f96c8f4825395366bcc5515e4d009960", "3850": "181ea8087ebeb2191bf1c2ce6114c0f5b17ab84c", "3853": "3056aae4f7d0cfbc1bd7061558e0170aa33788c3", "3857": "f10c16ac9b38f7bf2bce0e2335059c3f35bff78d", "3858": "aa304ff948f38439efa058d6627e7673c49a1260", "3860": "7eb6e01fa1b87d685000f821776851f78b0af8af", "3862": "b1d76b9e8d1a482c09e35a6b0c2675741ffefdc9", "3865": "c3dd1ef72aa7de51d84ab25ea4d936101d8a5802", "3866": "5a91dd26e2e1ab0545496726f7a434f53f2789c1", "3870": "21865564f6d4f11b397c0109cae08ec23206cef0", "3871": "da494ce457e22f81005896883c212afb83d77847", "3873": "112e186575f59afffdc9e271a5b6d52c8de3ea4d", "3878": "e7596c99dcb2449461ced9c16c69113a66505eee", "3882": "e05963849ef2c06d01c37d897e7cc19206ed2d80", "3884": "616e696e61f821cecaa6e9f8b36ea6fad617fb34", "3885": "1d5705a5c4a8b965640e278d0ce20469bfee5de6", "3888": "30193b7e81bf9dda692d890276c39defba11ac3c", "3893": "908ec070d837baf77d828d01c3e35e2f4bfa2bfa", "3895": "4dd3b9b45402288bc11242ebc1fd41e4a7995df8", "3904": "a82d7f483026984c298cb91a1954e24f86182d02", "3908": "95eaac98cb4a4e9aee60cee083326135a98cda57", "3912": "cb52e61ccbdab071e535cbee5f7693df4529faea", "3927": "4e40e943ea99c04c776488a2c0d66c00d90adeee", "3928": "2e9dc6d694feae2be378fa5351e2cf5ad0c19f1b", "3930": "ce174857361a0b2f241f1d906fb8dbc476521699", "3934": "97a01ee093b8347afbf50d79258d5b49b6a4c03a", "3940": "71da1e999636193fa80208a9ddb79af8ae79886c", "3943": "d752a0c918b82526e44744424a8a8fcacedf90d3", "3944": "5646f43553e4e785635dbec9f689e3bec0aa2570", "3948": "3ea156bd7fac422ffbe82d40cc1bc3b7afb25c3f", "3949": "89de1b8d3a718e6b970f0a059355d14ce4fbc3a2", "3951": "9ee54883f67b5b581d0a29dddd777e1b907235d9", "3955": "798726b792ace88c5ecc34059e3276f04d636cfe", "3956": "313b120db4a00b1cd45c413c1afb07d85d9e6159", "3958": "c87e131dd4c52efd7c4c53928a98401f0c732ee3", "3961": "c0025fdf4bc39661edeb905c0f46eaf8d1384c43", "3965": "a52ee30084549125ef34448f5ccf3013874331a9", "3972": "2a60b11f1ea8d14552d09f0c4f02d71f6586e762", "3974": "446b5469a0d06c2ba4216786d97701b776e038c2", "3980": "8e8711365899009634653cc7e11a8cd36001c0c7", "3984": "408e742e3610cbc6dc12528f0a19cc6c08c1479a", "3995": "e9de735d7f047fa5ab640fb0255c572d6bf436ae", "3996": "b7304549e04e94ccd0ad2bd26cd7bf5de0b36772", "3997": "9c44b8aedd7ca21c8f19fbccd2de35adf9435dfc", "4002": "52d915ff218b7357ba332ec2a93fc1d6d881aca8", "4007": "b22392cd9779e8b3278f16c021341fbb1a7daf9e", "4011": "663e85432767002b4aa641346bef66fbe03893c5", "4013": "41a82a3b828920646bb01eddf251b1712849a32a", "4016": "3c5b0f0e2387a3b53f7077fd5d51a9696da256e4", "4017": "f69281c500c8a1afb0f1fb28c6bcc0bb3e19d94d", "4022": "eb0300c467b4f7fe9a14c2bc1f5b88134602c648", "4023": "b309cfdbe800b1f9892c4dc4c664266a64c6f327", "4027": "19069c4222cce23dc0e2703cfbc62f0872627c33", "4028": "857b3f9435c475668cfb8df6332701b748983000", "4030": "29d53974d1ecad10c64c4c46192e995cbe46cd8d", "4035": "bb977467e42a36d393df6bad4d3a459d86defbb9", "4041": "c74f81e850d1d8fe442e9fb3c26f4d91a51bd416", "4044": "8f5038070f08eb0f3cc3352f80704162568de48b", "4045": "12914344e6fb6c483315d86c8a710ddd17cada22", "4052": "aeb9de1af4e3e9538411ab5c6670d50edde9ec6e", "4055": "c3b80c8db78057321cf5bfab4c2e0a665f46d274", "4056": "99d8234f403e91bbd8c95370c0d3ce6e7796b7fb", "4068": "876669c14d713dab40d26b80a07c68c0d42fd2f0", "4071": "8a110a5543ca396dc9eafd2bc9d4c5c7cbfa0742", "4076": "03e190da69b61ae017a20bc093864ce2726b9bdd", "4077": "ae008d7bb99b0ddae0e7364d078b6d5b2ac892f0", "4080": "a88be489820df3307206c6e68e4e3758b7f0b035", "4083": "1426933bf534233685ce643e9b5795def14aabd9", "4087": "6f2a8f6a0fdf8bdb50e68d14009332167ecf25fc", "4092": "97f7314e634608fc7e4928d1c0a57c8e2cbc1397", "4104": "b72c22154a4128cf4d68a90857cc45f31318cb7c", "4105": "fa05643be061547c74a1fc25cfa6a6c8bd086cb4", "4106": "e6ea9c70fefbe20d48cd1cda1902df22e9d9925a", "4110": "891dfbcce6ddafb87cd0d5622c6d0359ab074da7", "4114": "00c4edaf44bfa660f8401038945405c52ecabfc1", "4115": "d7bda5e12425a2d64e443314c1c6d530ee47b0eb", "4118": "dcdaa33cbb0109544e1252dfb9fc4b9cbcbbb839", "4119": "7b065d647ed84abfbd623492328b5c2ce054d63b", "4121": "7545ba141e3a11b796dc6d4e2a0d8f150f53d646", "4125": "22c607d63dff69b92a0e45e2ff000c151dc491a2", "4131": "e4cb53a1faa0ef48dc28ff8460266225f0e4cc63", "4132": "ffaa1e306c6b6a60045093d37878d5cc5529de32", "4133": "4e4b92bc916875ac8aceff8bcc970e8a25fe87fe", "4135": "3fe27beb4747707bcb4bd11447e17e8efa786d29", "4136": "7c13167052bd81e9a0ccf6774e54de528a75e752", "4139": "9e0371ec5955bbe5ff3b07616be03b6683e8dd75", "4143": "f6e3f39f62a49354c83fdec119b37967dbb40a26", "4147": "42330579b7355bbfd58481eb6b36fe12859f36b4", "4150": "1b5e7650ef3df20ffb5c59fa183cc250c46617a4", "4151": "75d5c220278f6f69726591dda59812d8f6d5cab5", "4156": "cee94b3697eeea5e6f8fe2d308752dcb99bd8859", "4159": "69258deecc947c77c7d381276c5c8a423808e4bb", "4160": "606326519c93fc7537c47747a9daf4b3c6f336cd", "4163": "0a8c9b12efcdbd1431ef644c8f6086e9fc5601a6", "4166": "e288c2b841091749b53e7c364d2bda533e691d57", "4167": "91ec1d74a5653faaa3d32b5fc4fc0cc18f874dca", "4170": "776fd869856322b05f42f81f4bd79e35d87f931e", "4171": "83eff647c74770709f9ca9e476e896370a8bd6dc", "4173": "4e8b2bd261746eb6a3d8e834b1a423b4f5bfb9c5", "4174": "608c5714c2975e8720512ea5186127ecc4c6ba35", "4176": "9df09d29230b45319a0006d736fce7a9460ce344", "4178": "9011cf369b43b5df8a368852b791489a8d8665c6", "4332": "d0dbbee13a8a211781178efb5e62bb404865b8e2", "4334": "3a1c32a1ae0222284c68627eff441c118ed399d4", "4337": "d4e1d01aa70bde33a0921d002d36749391715ee4", "4342": "b9a3238cd8a443044a6de543b3c13c57f7eca304", "4343": "7530e2d1d17753bd939e970f10db7e20b89a96e5", "4345": "53492cc021eff408c82d995a6f0fc53e31514688", "4349": "789bc7050891c597f0659a0355461259f76856fe", "4350": "341818b2fbd6ce2aa764fb6240ab25eb43304c80", "4353": "d53ed049df3793bf466d8c287dd0641fe10dbb48", "4357": "7124bdec641b69e05ec06e3d7f606bf46b622ca4", "4362": "7c5951f47514e607c47536d86953b9cc4a6f79e4", "4364": "7430749a23edb37334bdd905eb1f476596f85afa", "4365": "112b2aed8a3e24bee8fc16c325dcaccde0023148", "4367": "6a7fdcac1fe02e1a6260dad238e9b2467ea87863", "4372": "57371eb8c709952818408cbc875f4afe3a1b0ecc", "4376": "436bc0c45baf5660e7f89c58868de1b1d5ef7a66", "4382": "97fbd7c34e1fb0924a9154612b03bf32b1f21695", "4385": "36a7d1816c38e42bb176cef719400b505ac41517", "4387": "b69b4ad30e8222d87427439465b79e1e13cc8c5f", "4389": "4bc769037614e046588977a6640396c43d89dd91", "4392": "7a9303b5ba05d9e5747065a8d15e3ebd529ef9f3", "4394": "0fd91f4c6678bb700627a5953fd1c287f044ff8a", "4396": "b15045528406e787438a08c4701b797b7d28a8ad", "4400": "e04465a7c23ac84ecdd4596f93ecd516d3973b27", "4401": "7a1b8d1c99be68ea7db7c7c3e7700e8ec165557e", "4404": "c94c0a16b1e5fe5a8ddc5875b7cc80c792dfc7f2", "4406": "550e6dd518c6502e4d2fc9a326bf7ab8bcbf9b8d", "4411": "5f235a86b48572b93081970ea7124b5d08489cc9", "4412": "9c4caba08598920f2f7f4a65965b35d3dc7bfa99", "4414": "275f69bb977f74f65603e1e53bac7e947d96980c", "4416": "ca485778f420811877cfecc4dd7e7ae69230576b", "4420": "9e9f688bb8ebd60c829a3ab89801a8a8aa00b68c", "4421": "6a0d7b88a80d75734e3afe224ffcf25871b12e38", "4422": "972dc49714a8196eb2896b8745788c2ce22bfd47", "4426": "1fe209539a251ae75f9de34c3e1bc4f5f6ba08f8", "4436": "aa4ddde9aaf159fab38fcb5b3b8ba81882edf51a", "4441": "7ef6ee73930145b06a2ee55affdb8f0db8be6d3a", "4442": "109a65cb6490cd8a44f526c140f696e1a28569b2", "4443": "3e73ff657f920aadc0dd6d4e730074512f6b0a93", "4444": "7bf429f43bd381f02cf7d0125cc9acfee4072d2c", "4445": "e562d48a3c181acc053ef90d5ce6370d7b531974", "4448": "5f704ece7b1ab1acf74bf96319509862af3f09b1", "4452": "d99c37296b23c3f650557a37af36f386e41ba605", "4455": "173755da6115034f5d715713503382ae78b592e1", "4457": "ef7cce369e6acc3094f8e018ab90941d41f2ee53", "4458": "f63ff4da9916a8bf2b64591d03da9b042f3bed67", "4460": "275a7d86b84cbe6a81da5495c110aab28e4841ce", "4463": "ea2ce4dbf6fdd96ce4529983f7f560b3436cd344", "4465": "6832b2a4f526901c9cbaddfa80efb0f5552c807c", "4466": "5c9390542db1f92c0fabbb3838bd775a16d9cb0c", "4469": "fb4a6602f81b68b66801cf7ca201be1d86c7105f", "4470": "7a94ea38969f367f3297106cfca297e9222b8786", "4473": "14b96358af62b86c90f32fefe17db93d3554d345", "4479": "aff48535d3e954a850b64d676cc5fb9633184a20", "4480": "9a1b1c08cf9d3478be3b6313ac8ebca9e5b88e65", "4483": "09751619616c4567b6619dd9405b9f750ca122d1", "4485": "06a21d9634952297dd19404b8dc8a2d78e2d179b", "4488": "bf23c1515a8c48b1854c11a5a137c08ea585888d", "4490": "cb506a21fe91ae6a668ff2c94e81823a4bbfb16f", "4491": "05d8522212889200425172c8ce0c9a64e994c5a6", "4495": "b9c4d9d61226d0ad6574412391e07bc4840aec10", "4496": "5bfc3ebd6408cfdcd8664a583ab2d84c43dd44ea", "4497": "0913bfd0644cf34413652eda897acd24add238c1", "4501": "6ed75b078235bee3df2a2a9715462e2c0db3f158", "4502": "03033c68ec5c32f1b0798a290439723b84200651", "4505": "2c63a59aac59f85ad7b03ca04d68f3c4bfeea709", "4506": "0b8c707d9aac631488e00ee9b28050fbd6dfbf73", "4508": "cdab136737aec1981e621d396b69806972236b79", "4511": "9a5b1c1056cdc4e47cef166d56e18ce33d4c9e6e", "4513": "c6ba82851137ec316cbef79a24956f4afd4814e7", "4515": "0f658c30ca00e3879c4e16d61db926dee2fdedc6", "4516": "176296d2bab274dbaff1c4ced12c83d0a326b8ab", "4518": "cf15232ddcf29a37830747332e0430049f4a9c33", "4523": "725cda6391f832ad6bb3665396aec4ff135fa216", "4525": "f59172683eb5dbf90237df408799a17635a0ed2c", "4527": "b8b14ec6db44376d1114b243d743cd47741b41d2", "4530": "1406cfa6bc9671f112b56bab163036082d15cfc0", "4539": "8338dfff632dec762a614f11d10df024a1bedca9", "4541": "44d09372e153cd1a8d6c44d2b2a5f3820c70828a", "4543": "fa445bb65e817fe2a060613c6cfadefb4bef3e96", "4550": "eef4a18e6d111bb3e5e6e06c628a84c162d9d45d", "4551": "32677ebb4434684c03e573a34ffa19218e39ecb7", "4553": "5280fc567e5fa703ef4819ce5c5aa80c6f50d2d4", "4556": "03268476f89fe22f56a3b367eda345953fcae4d0", "4557": "cc085b1b19442d535d919f6e05ebc0e7a70a542c", "4559": "e6e1c640d12f3ddfb98d0af02cb6f1d7092a376a", "4566": "30df4d3ac4aca3fb883b6dac89c0217b4b78390d", "4572": "bf9f96c5731cd7b5091775f7cb3023f7c6091210", "4575": "b4e6cb8275f98aeffbceb472148b3e6eb4b6bbc8", "4577": "9b5aced7ab8411bfcb35a1b9d00961dba06e8a4e", "4578": "5ae73ddab86b63919a3e518d3ba92134dc9f1bc5", "4580": "2127a342e6e1e27f587541e105b7dc5f6fc24408", "4581": "2197a0fbe3c56dceebf2362b63b46e034b996bf7", "4582": "c93d76e3847a3f1d288070e379ee386c57274aa2", "4584": "7e1b5af2dddfabc50bd2a977f0178be269b349b5", "4588": "2ae2a211b33f9e0dd87f56f1389a79dc3cf35ace", "4592": "e20183c2faffbc9f1e328e9fb31c794562ab980c", "4593": "3ab12f6bac6d21e22344dbb72ac2165fe585747c"}, "revision_to_date": {"3517": 1505205617000, "3541": 1507981726000, "3663": 1517828625000, "3669": 1518173178000, "3783": 1524511318000, "3791": 1524680968000, "3796": 1524730735000, "3799": 1524814193000, "3800": 1524823160000, "3807": 1525003082000, "3809": 1525041534000, "3813": 1525107176000, "3815": 1525162255000, "3816": 1525179214000, "3822": 1525629568000, "3823": 1525676320000, "3825": 1525108893000, "3830": 1526018038000, "3831": 1526021739000, "3845": 1526409636000, "3848": 1526465038000, "3850": 1526569081000, "3853": 1526755374000, "3857": 1526983798000, "3858": 1526986111000, "3860": 1527070494000, "3862": 1527157063000, "3865": 1527225127000, "3866": 1527270352000, "3870": 1527569681000, "3871": 1527607913000, "3873": 1527836849000, "3878": 1528095883000, "3882": 1528226883000, "3884": 1528284343000, "3885": 1528289518000, "3888": 1528349086000, "3893": 1528663468000, "3895": 1529058143000, "3904": 1529398857000, "3908": 1529567417000, "3912": 1529666927000, "3927": 1531250148000, "3928": 1531303810000, "3930": 1531372493000, "3934": 1531461211000, "3940": 1531569839000, "3943": 1531734870000, "3944": 1531757024000, "3948": 1531823110000, "3949": 1531826652000, "3951": 1531892382000, "3955": 1531987853000, "3956": 1531987872000, "3958": 1532329050000, "3961": 1532707721000, "3965": 1532760697000, "3972": 1532961387000, "3974": 1533028099000, "3980": 1533415000000, "3984": 1533566989000, "3995": 1533759182000, "3996": 1533793408000, "3997": 1533793606000, "4002": 1534259243000, "4007": 1534859610000, "4011": 1534867808000, "4013": 1534974302000, "4016": 1535435680000, "4017": 1535441441000, "4022": 1535621036000, "4023": 1535660398000, "4027": 1535970136000, "4028": 1535970211000, "4030": 1536130435000, "4035": 1536261967000, "4041": 1536656259000, "4044": 1536841499000, "4045": 1536930561000, "4052": 1537000295000, "4055": 1537078610000, "4056": 1537078658000, "4068": 1537426387000, "4071": 1537463216000, "4076": 1537599571000, "4077": 1537644284000, "4080": 1537729253000, "4083": 1537883170000, "4087": 1538248396000, "4092": 1538512893000, "4104": 1538809054000, "4105": 1538821407000, "4106": 1538846821000, "4110": 1538896885000, "4114": 1539028624000, "4115": 1539084114000, "4118": 1539147707000, "4119": 1539189519000, "4121": 1539411693000, "4125": 1539506899000, "4131": 1539704221000, "4132": 1539704249000, "4133": 1539704296000, "4135": 1539755387000, "4136": 1539755422000, "4139": 1539887506000, "4143": 1539980837000, "4147": 1540794366000, "4150": 1540845374000, "4151": 1540879190000, "4156": 1540912208000, "4159": 1540972206000, "4160": 1540972312000, "4163": 1541139930000, "4166": 1541234809000, "4167": 1541234823000, "4170": 1541318665000, "4171": 1541343592000, "4173": 1541486306000, "4174": 1541319218000, "4176": 1541929271000, "4178": 1541971462000, "4332": 1542366531000, "4334": 1542442012000, "4337": 1542744264000, "4342": 1542907778000, "4343": 1542907796000, "4345": 1542963150000, "4349": 1543254151000, "4350": 1543386551000, "4353": 1543523817000, "4357": 1543737474000, "4362": 1543856237000, "4364": 1543954956000, "4365": 1543954967000, "4367": 1544078221000, "4372": 1544442398000, "4376": 1544507795000, "4382": 1545039869000, "4385": 1545074629000, "4387": 1545116276000, "4389": 1545156531000, "4392": 1545298367000, "4394": 1545419057000, "4396": 1545461433000, "4400": 1546242214000, "4401": 1546242918000, "4404": 1546331808000, "4406": 1546599475000, "4411": 1547038592000, "4412": 1547047192000, "4414": 1547058992000, "4416": 1547113996000, "4420": 1547201533000, "4421": 1547233364000, "4422": 1547243187000, "4426": 1547326638000, "4436": 1547620925000, "4441": 1547751948000, "4442": 1547809983000, "4443": 1547810113000, "4444": 1547750395000, "4445": 1547849718000, "4448": 1548253892000, "4452": 1548409411000, "4455": 1548754426000, "4457": 1548858791000, "4458": 1549010074000, "4460": 1549211399000, "4463": 1549353975000, "4465": 1549401775000, "4466": 1549401910000, "4469": 1549647401000, "4470": 1549647412000, "4473": 1550082396000, "4479": 1550165720000, "4480": 1550165734000, "4483": 1550300838000, "4485": 1550392953000, "4488": 1550587352000, "4490": 1550782986000, "4491": 1550783062000, "4495": 1551209661000, "4496": 1551254350000, "4497": 1551255972000, "4501": 1551554183000, "4502": 1551596149000, "4505": 1551642871000, "4506": 1551681838000, "4508": 1551816581000, "4511": 1551938699000, "4513": 1551985411000, "4515": 1552139187000, "4516": 1552139196000, "4518": 1552723885000, "4523": 1552807496000, "4525": 1552937233000, "4527": 1553028823000, "4530": 1553275846000, "4539": 1553722833000, "4541": 1553884383000, "4543": 1554026750000, "4550": 1554221961000, "4551": 1554230792000, "4553": 1554356287000, "4556": 1554440958000, "4557": 1554462924000, "4559": 1554711673000, "4566": 1555616297000, "4572": 1556138541000, "4575": 1556221530000, "4577": 1556258966000, "4578": 1556299839000, "4580": 1556313755000, "4581": 1556366403000, "4582": 1556430260000, "4584": 1556514463000, "4588": 1556625207000, "4592": 1556655995000, "4593": 1556690880000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz"], "machine": ["ssp"], "numpy": [""], "os": ["Linux 3.10.0-891.el7.x86_64"], "python": ["3.6"], "ram": ["15908200"], "branch": ["master"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz", "machine": "ssp", "numpy": "", "os": "Linux 3.10.0-891.el7.x86_64", "python": "3.6", "ram": "15908200", "branch": "master"}], "benchmarks": {"benchmarks.TimeSuite.time_allpairs_distances": {"code": "#setup: import numpy as np ; np.random.seed(0); N = 500 ; X, Y = np.random.randn(100,N), np.random.randn(40,N)\n#run: allpairs_distances(X, Y)\n\n#pythran export allpairs_distances(float64[][], float64[][])\nimport numpy as np\n\ndef allpairs_distances(X,Y):\n  return np.array([[np.sum( (x-y) ** 2) for x in X] for y in Y])", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_allpairs_distances", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "a9239e03cf328201996aa3cfa2a5b8c91cc5d92b926b14d6cc588f96f2bd1e8b", "warmup_time": -1}, "benchmarks.TimeSuite.time_allpairs_distances_loops": {"code": "#setup: import numpy as np ; np.random.seed(0); N = 500 ; X, Y = np.random.randn(100,N), np.random.randn(40,N)\n#run: allpairs_distances_loops(X, Y)\n\n#pythran export allpairs_distances_loops(float64[][], float64[][])\nimport numpy as np\n\ndef allpairs_distances_loops(X,Y):\n  result = np.zeros( (X.shape[0], Y.shape[0]), X.dtype)\n  for i in range(X.shape[0]):\n    for j in range(Y.shape[0]):\n      result[i,j] = np.sum( (X[i,:] - Y[j,:]) ** 2)\n  return result", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_allpairs_distances_loops", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "f9722767f834a7e9a14a784c891e83de3682c0009e7c0fac3defcba52a0eca03", "warmup_time": -1}, "benchmarks.TimeSuite.time_arc_distance": {"code": "#setup: N = 10000 ; import numpy as np ; np.random.seed(0); t0, p0, t1, p1 = np.random.randn(N), np.random.randn(N), np.random.randn(N), np.random.randn(N)\n#run: arc_distance(t0, p0, t1, p1)\n\n#pythran export arc_distance(float64 [], float64[], float64[], float64[])\n\nimport numpy as np\ndef arc_distance(theta_1, phi_1,\n                       theta_2, phi_2):\n    \"\"\"\n    Calculates the pairwise arc distance between all points in vector a and b.\n    \"\"\"\n    temp = np.sin((theta_2-theta_1)/2)**2+np.cos(theta_1)*np.cos(theta_2)*np.sin((phi_2-phi_1)/2)**2\n    distance_matrix = 2 * (np.arctan2(np.sqrt(temp),np.sqrt(1-temp)))\n    return distance_matrix", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_arc_distance", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "f146b71ded4c39003b8b942b99e602a4cc9469a3b7850f4e23b26b4fedbf73af", "warmup_time": -1}, "benchmarks.TimeSuite.time_check_mask": {"code": "#setup: n=1000 ; import numpy as np; np.random.seed(0); db = np.array(np.random.randint(2, size=(n, 4)), dtype=bool)\n#run: check_mask(db)\n#from: http://stackoverflow.com/questions/34500913/numba-slower-for-numpy-bitwise-and-on-boolean-arrays\n\n#pythran export check_mask(bool[][])\nimport numpy as np\ndef check_mask(db, mask=[1, 0, 1]):\n    out = np.zeros(db.shape[0],dtype=bool)\n    for idx, line in enumerate(db):\n        target, vector = line[0], line[1:]\n        if (mask == np.bitwise_and(mask, vector)).all():\n            if target == 1:\n                out[idx] = 1\n    return out", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_check_mask", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "368edbe8610d4ccf58c99d23837fa2f02d4741b4ff4fd1d07a96718e3b1743db", "warmup_time": -1}, "benchmarks.TimeSuite.time_conv": {"code": "#setup: N = 200 ; import numpy as np ; x = np.tri(N,N)*0.5 ; w = np.tri(5,5)*0.25\n#run: conv(x,w)\n\n#pythran export conv(float[][], float[][])\nimport numpy as np\n\ndef clamp(i, offset, maxval):\n    j = max(0, i + offset)\n    return min(j, maxval)\n\n\ndef reflect(pos, offset, bound):\n    idx = pos+offset\n    return min(2*(bound-1)-idx,max(idx,-idx))\n\n\ndef conv(x, weights):\n    sx = x.shape\n    sw = weights.shape\n    result = np.zeros_like(x)\n    for i in range(sx[0]):\n        for j in range(sx[1]):\n            for ii in range(sw[0]):\n                for jj in range(sw[1]):\n                    idx = clamp(i,ii-sw[0]//2,sw[0]), clamp(j,jj-sw[0]//2,sw[0])\n                    result[i,j] += x[idx] * weights[ii,jj]\n    return result", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_conv", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "d734799bdcd9203e25bfae0e8c0e2c6e6123c0dc8341251f4e516275c83fe95e", "warmup_time": -1}, "benchmarks.TimeSuite.time_create_grid": {"code": "#from: http://stackoverflow.com/questions/13815719/creating-grid-with-numpy-performance\n#pythran export create_grid(float [])\n#setup: import numpy as np ; N = 800 ; x = np.arange(0,1,1./N)\n#run: create_grid(x)\nimport numpy as np\ndef create_grid(x):\n    N = x.shape[0]\n    z = np.zeros((N, N, 3))\n    z[:,:,0] = x.reshape(-1,1)\n    z[:,:,1] = x\n    fast_grid = z.reshape(N*N, 3)\n    return fast_grid", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_create_grid", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "7fb29002759465feb7a1b89c5d54d17231e714f6c4315ec37319ad0657825718", "warmup_time": -1}, "benchmarks.TimeSuite.time_cronbach": {"code": "#from: http://stackoverflow.com/questions/20799403/improving-performance-of-cronbach-alpha-code-python-numpy\n#pythran export cronbach(float [][])\n#setup: import numpy as np ; np.random.seed(0); N = 600 ; items = np.random.rand(N,N)\n#run: cronbach(items)\ndef cronbach(itemscores):\n    itemvars = itemscores.var(axis=1, ddof=1)\n    tscores = itemscores.sum(axis=0)\n    nitems = len(itemscores)\n    return nitems / (nitems-1) * (1 - itemvars.sum() / tscores.var(ddof=1))", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_cronbach", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "f84ca7da1f35d25caef9bae0a84da42d2bcc622b4791dada51de75ac752cbe8a", "warmup_time": -1}, "benchmarks.TimeSuite.time_diffusion": {"code": "#setup: import numpy as np;lx,ly=(2**7,2**7);u=np.zeros([lx,ly],dtype=np.double);u[lx//2,ly//2]=1000.0;tempU=np.zeros([lx,ly],dtype=np.double)\n#run: diffusion(u,tempU,100)\n\n#pythran export diffusion(float [][], float [][], int)\nimport numpy as np\n\n\ndef diffusion(u, tempU, iterNum):\n    \"\"\"\n    Apply Numpy matrix for the Forward-Euler Approximation\n    \"\"\"\n    mu = .1\n\n    for n in range(iterNum):\n        tempU[1:-1, 1:-1] = u[1:-1, 1:-1] + mu * (\n            u[2:, 1:-1] - 2 * u[1:-1, 1:-1] + u[0:-2, 1:-1] +\n            u[1:-1, 2:] - 2 * u[1:-1, 1:-1] + u[1:-1, 0:-2])\n        u[:, :] = tempU[:, :]\n        tempU[:, :] = 0.0", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_diffusion", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "9c20be9b881dfa28b7f150ee5fc8cfec83a5ce60e2d07bf76b6e0db595c26417", "warmup_time": -1}, "benchmarks.TimeSuite.time_euclidean_distance_square": {"code": "#from:  https://stackoverflow.com/questions/50658884/why-this-numba-code-is-6x-slower-than-numpy-code\n#setup: import numpy as np; np.random.seed(0); x1 = np.random.random((1, 512)); x2 = np.random.random((10000, 512))\n#run: euclidean_distance_square(x1, x2)\n#pythran export euclidean_distance_square(float64[1,:], float64[:,:])\nimport numpy as np\ndef euclidean_distance_square(x1, x2):\n    return -2*np.dot(x1, x2.T) + np.sum(np.square(x1), axis=1)[:, np.newaxis] + np.sum(np.square(x2), axis=1)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_euclidean_distance_square", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "e61f8b3212006f3ea0321a9d8f2d60ce6d4a943ed1a337549a49d6c228b45196", "warmup_time": -1}, "benchmarks.TimeSuite.time_evolve": {"code": "#setup: import numpy as np ; grid_shape = (512, 512) ; grid = np.zeros(grid_shape) ; block_low = int(grid_shape[0] * .4) ; block_high = int(grid_shape[0] * .5) ; grid[block_low:block_high, block_low:block_high] = 0.005\n#run: evolve(grid, 0.1)\n#from: High Performance Python by Micha Gorelick and Ian Ozsvald, http://shop.oreilly.com/product/0636920028963.do\n\n#pythran export evolve(float64[][], float)\nimport numpy as np\ndef laplacian(grid):\n    return np.roll(grid, +1, 0) + np.roll(grid, -1, 0) + np.roll(grid, +1, 1) + np.roll(grid, -1, 1) - 4 * grid\n\ndef evolve(grid, dt, D=1):\n    return grid + dt * D * laplacian(grid)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_evolve", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "3129de74de25fceeb0e68d18c75358fe8ce9b18371d1b5f249b29495316e2c47", "warmup_time": -1}, "benchmarks.TimeSuite.time_fdtd": {"code": "#from: http://stackoverflow.com/questions/19367488/converting-function-to-numbapro-cuda\n#setup: N = 100 ; import numpy ; numpy.random.seed(0); a = numpy.random.rand(N,N)\n#run: fdtd(a,40)\n\n#pythran export fdtd(float[][], int)\nimport numpy as np\n\ndef fdtd(input_grid, steps):\n    grid = input_grid.copy()\n    old_grid = np.zeros_like(input_grid)\n    previous_grid = np.zeros_like(input_grid)\n\n    l_x = grid.shape[0]\n    l_y = grid.shape[1]\n\n    for i in range(steps):\n        np.copyto(previous_grid, old_grid)\n        np.copyto(old_grid, grid)\n\n        for x in range(l_x):\n            for y in range(l_y):\n                grid[x,y] = 0.0\n                if 0 < x+1 < l_x:\n                    grid[x,y] += old_grid[x+1,y]\n                if 0 < x-1 < l_x:\n                    grid[x,y] += old_grid[x-1,y]\n                if 0 < y+1 < l_y:\n                    grid[x,y] += old_grid[x,y+1]\n                if 0 < y-1 < l_y:\n                    grid[x,y] += old_grid[x,y-1]\n\n                grid[x,y] /= 2.0\n                grid[x,y] -= previous_grid[x,y]\n\n    return grid", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_fdtd", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "1e4581cd98de8cdf1bc2242fe9b6d7ff7dc56574c606817898dc36f9c056731a", "warmup_time": -1}, "benchmarks.TimeSuite.time_fft": {"code": "#setup: N = 2**10 ; import numpy as np ; np.random.seed(0); a = np.array(np.random.rand(N), dtype=complex)\n#run: fft(a)\n\n#pythran export fft(complex [])\n\nimport math, numpy as np\n\ndef fft(x):\n   N = x.shape[0]\n   if N == 1:\n       return np.array(x)\n   e=fft(x[::2])\n   o=fft(x[1::2])\n   M=N//2\n   l=e + o * math.e**(-2j*math.pi*np.arange(M)/N)\n   r=e - o * math.e**(-2j*math.pi*np.arange(M)/N)\n   return np.array(l+r)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_fft", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "9f8c9857d7cc9aa844b708972e2d4fd49867dfb35559a4b25611036d18321e85", "warmup_time": -1}, "benchmarks.TimeSuite.time_grayscott": {"code": "#from http://stackoverflow.com/questions/26823312/numba-or-cython-acceleration-in-reaction-diffusion-algorithm\n#setup: pass\n#run: grayscott(40, 0.16, 0.08, 0.04, 0.06)\n\n#pythran export grayscott(int, float, float, float, float)\nimport numpy as np\ndef grayscott(counts, Du, Dv, F, k):\n    n = 300\n    U = np.zeros((n+2,n+2), dtype=np.float32)\n    V = np.zeros((n+2,n+2), dtype=np.float32)\n    u, v = U[1:-1,1:-1], V[1:-1,1:-1]\n\n    r = 20\n    u[:] = 1.0\n    U[n//2-r:n//2+r,n//2-r:n//2+r] = 0.50\n    V[n//2-r:n//2+r,n//2-r:n//2+r] = 0.25\n    u += 0.15*np.random.random((n,n))\n    v += 0.15*np.random.random((n,n))\n\n    for i in range(counts):\n        Lu = (                 U[0:-2,1:-1] +\n              U[1:-1,0:-2] - 4*U[1:-1,1:-1] + U[1:-1,2:] +\n                               U[2:  ,1:-1] )\n        Lv = (                 V[0:-2,1:-1] +\n              V[1:-1,0:-2] - 4*V[1:-1,1:-1] + V[1:-1,2:] +\n                               V[2:  ,1:-1] )\n        uvv = u*v*v\n        u += Du*Lu - uvv + F*(1 - u)\n        v += Dv*Lv + uvv - (F + k)*v\n\n    return V", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_grayscott", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "f676d702736c770b9b54c76f04f55f976cdbb5a84a873900db9719a1a7bafd24", "warmup_time": -1}, "benchmarks.TimeSuite.time_grouping": {"code": "#from: http://stackoverflow.com/questions/4651683/numpy-grouping-using-itertools-groupby-performance\n#setup: import numpy as np ; N = 500000 ; np.random.seed(0); values = np.array(np.random.randint(0,3298,size=N),dtype='u4') ; values.sort()\n#run: grouping(values)\n\n#pythran export grouping(uint32 [])\n\ndef grouping(values):\n    import numpy as np\n    diff = np.concatenate(([1], np.diff(values)))\n    idx = np.concatenate((np.where(diff)[0], [len(values)]))\n    return values[idx[:-1]], np.diff(idx)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_grouping", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "a0878fcb9cdf9059e20feb21e22456d9b5fb1e671a0fea281e232bf9e8dd6932", "warmup_time": -1}, "benchmarks.TimeSuite.time_growcut": {"code": "#from: http://continuum.io/blog/numba_performance\n#setup: N = 40 ; import numpy as np ; image = np.random.rand(N, N, 3) ; state = np.zeros((N, N, 2)) ; state_next = np.empty_like(state) ; state[0, 0, 0] = state[0, 0, 1] = 1\n#run: growcut(image, state, state_next, 10)\n\n#pythran export growcut(float[][][], float[][][], float[][][], int)\nimport math\nimport numpy as np\ndef window_floor(idx, radius):\n    if radius > idx:\n        return 0\n    else:\n        return idx - radius\n\n\ndef window_ceil(idx, ceil, radius):\n    if idx + radius > ceil:\n        return ceil\n    else:\n        return idx + radius\n\ndef growcut(image, state, state_next, window_radius):\n    changes = 0\n    sqrt_3 = math.sqrt(3.0)\n\n    height = image.shape[0]\n    width = image.shape[1]\n\n    for j in range(width):\n        for i in range(height):\n\n            winning_colony = state[i, j, 0]\n            defense_strength = state[i, j, 1]\n\n            for jj in range(window_floor(j, window_radius),\n                             window_ceil(j+1, width, window_radius)):\n                for ii in range(window_floor(i, window_radius),\n                                 window_ceil(i+1, height, window_radius)):\n                    if (ii != i and jj != j):\n                        d = image[i, j, 0] - image[ii, jj, 0]\n                        s = d * d\n                        for k in range(1, 3):\n                            d = image[i, j, k] - image[ii, jj, k]\n                            s += d * d\n                        gval = 1.0 - math.sqrt(s)/sqrt_3\n\n                        attack_strength = gval * state[ii, jj, 1]\n\n                        if attack_strength > defense_strength:\n                            defense_strength = attack_strength\n                            winning_colony = state[ii, jj, 0]\n                            changes += 1\n\n            state_next[i, j, 0] = winning_colony\n            state_next[i, j, 1] = defense_strength\n\n    return changes", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_growcut", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "585bc9739c60a1e38c9116aca4cae0880c0f61e7fa594ac4e1946793210eaeb5", "warmup_time": -1}, "benchmarks.TimeSuite.time_harris": {"code": "#from: parakeet testbed\n#setup: import numpy as np ; M, N = 512, 512 ; I = np.random.randn(M,N)\n#run: harris(I)\n\n#pythran export harris(float64[][])\nimport numpy as np\n\n\n\ndef harris(I):\n  m,n = I.shape\n  dx = (I[1:, :] - I[:m-1, :])[:, 1:]\n  dy = (I[:, 1:] - I[:, :n-1])[1:, :]\n\n  #\n  #   At each point we build a matrix\n  #   of derivative products\n  #   M =\n  #   | A = dx^2     C = dx * dy |\n  #   | C = dy * dx  B = dy * dy |\n  #\n  #   and the score at that point is:\n  #      det(M) - k*trace(M)^2\n  #\n  A = dx * dx\n  B = dy * dy\n  C = dx * dy\n  tr = A + B\n  det = A * B - C * C\n  k = 0.05\n  return det - k * tr * tr", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_harris", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "5948749cff8d278308922692ee0dcc29abf10193adf498731fa0f199aaf8d488", "warmup_time": -1}, "benchmarks.TimeSuite.time_hasting": {"code": "#from: http://wiki.scipy.org/Cookbook/Theoretical_Ecology/Hastings_and_Powell\n#setup: import numpy as np ; y = np.random.rand(3) ; args = np.random.rand(7)\n#run: hasting(y, *args)\n\n#pythran export hasting(float [], float, float, float, float, float, float, float)\nimport numpy as np\ndef hasting(y, t, a1, a2, b1, b2, d1, d2):\n    yprime = np.empty((3,))\n    yprime[0] = y[0] * (1. - y[0]) - a1*y[0]*y[1]/(1. + b1 * y[0])\n    yprime[1] = a1*y[0]*y[1] / (1. + b1 * y[0]) - a2 * y[1]*y[2] / (1. + b2 * y[1]) - d1 * y[1]\n    yprime[2] = a2*y[1]*y[2]/(1. + b2*y[1]) - d2*y[2]\n    return yprime", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_hasting", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "4c51f13035e33e99fecbefb38ca5914bfcba014b980bd6d0f7d4a78ee3cb2e90", "warmup_time": -1}, "benchmarks.TimeSuite.time_hyantes": {"code": "#setup: import numpy ; a = numpy.array([ [i/10., i/10., i/20.] for i in range(80)], dtype=numpy.double)\n#run: hyantes(0., 0., 90., 90., 1., 100., 80, 80, a)\n\n#pythran export hyantes(float, float, float, float, float, float, int, int, float[][])\nimport numpy as np\ndef hyantes(xmin, ymin, xmax, ymax, step, range_, range_x, range_y, t):\n    X,Y = t.shape\n    pt = np.zeros((X,Y))\n    for i in range(X):\n        for j in range(Y):\n            for k in t:\n                tmp = 6368.* np.arccos( np.cos(xmin+step*i)*np.cos( k[0] ) * np.cos((ymin+step*j)-k[1])+  np.sin(xmin+step*i)*np.sin(k[0]))\n                if tmp < range_:\n                    pt[i,j]+=k[2] / (1+tmp)\n    return pt", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_hyantes", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "edde9b01c068d524b68e39a4a502e18644effab5ec851d41435f8fa1e3c383eb", "warmup_time": -1}, "benchmarks.TimeSuite.time_julia": {"code": "#setup: N=500\n#run: julia(1., 1., N, 1.5, 10., 1e4)\n\n#pythran export julia(float, float, int, float, float, float)\nimport numpy as np\nfrom time import time\n\ndef kernel(zr, zi, cr, ci, lim, cutoff):\n    ''' Computes the number of iterations `n` such that \n        |z_n| > `lim`, where `z_n = z_{n-1}**2 + c`.\n    '''\n    count = 0\n    while ((zr*zr + zi*zi) < (lim*lim)) and count < cutoff:\n        zr, zi = zr * zr - zi * zi + cr, 2 * zr * zi + ci\n        count += 1\n    return count\n\ndef julia(cr, ci, N, bound=1.5, lim=1000., cutoff=1e6):\n    ''' Pure Python calculation of the Julia set for a given `c`.  No NumPy\n        array operations are used.\n    '''\n    julia = np.empty((N, N), np.uint32)\n    grid_x = np.linspace(-bound, bound, N)\n    for i, x in enumerate(grid_x):\n        for j, y in enumerate(grid_x):\n            julia[i,j] = kernel(x, y, cr, ci, lim, cutoff)\n    return julia", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_julia", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "daaddc1d265c11dc1389357804c2e29a51f9f21eadf0770124b33aa3736d7582", "warmup_time": -1}, "benchmarks.TimeSuite.time_l2norm": {"code": "#from: http://stackoverflow.com/questions/7741878/how-to-apply-numpy-linalg-norm-to-each-row-of-a-matrix/7741976#7741976\n#setup: import numpy as np ; N = 1000; x = np.random.rand(N,N)\n#run: l2norm(x)\n\n#pythran export l2norm(float64[][])\nimport numpy as np\ndef l2norm(x):\n    return np.sqrt(np.sum(np.abs(x)**2, 1))", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_l2norm", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "930e21165fc2ce72848fcb748ea15caebe65fc1b77883d34dc316b02824ce8af", "warmup_time": -1}, "benchmarks.TimeSuite.time_laplacien": {"code": "#setup: import numpy as np ; N = 500 ; X = np.random.randn(N,N,3)\n#run: laplacien(X)\n#pythran export laplacien(float64[][][3])\n\nimport numpy as np\ndef laplacien(image):\n        out_image = np.abs(4*image[1:-1,1:-1] -\n                                       image[0:-2,1:-1] - image[2:,1:-1] -\n                                       image[1:-1,0:-2] - image[1:-1,2:])\n        valmax = np.max(out_image)\n        valmax = max(1.,valmax)+1.E-9\n        out_image /= valmax\n        return out_image", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_laplacien", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "d4644a739ca5d36ecdfdd8314fefee7a01a71387d83384b916a3fa025a68bfe6", "warmup_time": -1}, "benchmarks.TimeSuite.time_local_maxima": {"code": "#from: https://github.com/iskandr/parakeet/blob/master/benchmarks/nd_local_maxima.py\n#setup: import numpy as np ; shape = (5,4,3,2) ; x = np.arange(120, dtype=np.float64).reshape(*shape)\n#run: local_maxima(x)\n\n#pythran export local_maxima(float [][][][])\nimport numpy as np\n\ndef wrap(pos, offset, bound):\n    return ( pos + offset ) % bound\n\ndef clamp(pos, offset, bound):\n    return min(bound-1,max(0,pos+offset))\n\ndef reflect(pos, offset, bound):\n    idx = pos+offset\n    return min(2*(bound-1)-idx,max(idx,-idx))\n\n\ndef local_maxima(data, mode=wrap):\n  wsize = data.shape\n  result = np.ones(data.shape, bool)\n  for pos in np.ndindex(data.shape):\n    myval = data[pos]\n    for offset in np.ndindex(wsize):\n      neighbor_idx = tuple(mode(p, o-w//2, w) for (p, o, w) in zip(pos, offset, wsize))\n      result[pos] &= (data[neighbor_idx] <= myval)\n  return result", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_local_maxima", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "f3732a46df14d89f1175bb6c95088cf83f18891ced408f22e2e647caba4242ca", "warmup_time": -1}, "benchmarks.TimeSuite.time_log_likelihood": {"code": "#setup: import numpy as np ; N = 100000 ; a = np.random.random(N); b = 0.1; c =1.1\n#run: log_likelihood(a, b, c)\n#from: http://arogozhnikov.github.io/2015/09/08/SpeedBenchmarks.html\nimport numpy\n\n#pythran export log_likelihood(float64[], float64, float64)\ndef log_likelihood(data, mean, sigma):\n    s = (data - mean) ** 2 / (2 * (sigma ** 2))\n    pdfs = numpy.exp(- s)\n    pdfs /= numpy.sqrt(2 * numpy.pi) * sigma\n    return numpy.log(pdfs).sum()", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_log_likelihood", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "95d34ff964edcc86898a58660cf2cf3893cbc5d33479a6aad0b61bad996cada3", "warmup_time": -1}, "benchmarks.TimeSuite.time_lstsqr": {"code": "#setup: import numpy as np ; N = 500000 ; X, Y = np.random.rand(N), np.random.rand(N)\n#run: lstsqr(X, Y)\n#from: http://nbviewer.ipython.org/github/rasbt/One-Python-benchmark-per-day/blob/master/ipython_nbs/day10_fortran_lstsqr.ipynb\n\n#pythran export lstsqr(float[], float[])\nimport numpy as np\ndef lstsqr(x, y):\n    \"\"\" Computes the least-squares solution to a linear matrix equation. \"\"\"\n    x_avg = np.average(x)\n    y_avg = np.average(y)\n    dx = x - x_avg\n    dy = y - y_avg\n    var_x = np.sum(dx**2)\n    cov_xy = np.sum(dx * (y - y_avg))\n    slope = cov_xy / var_x\n    y_interc = y_avg - slope*x_avg\n    return (slope, y_interc)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_lstsqr", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "77f19a8f4bff52fb1f97611e2048c5be50360232f7dd06e31900dd602a85f1fb", "warmup_time": -1}, "benchmarks.TimeSuite.time_make_decision": {"code": "#setup: import numpy as np, random; np.random.seed(0); s=np.random.randn(2**16)+np.random.randn(2**16)*1.j ; sc=np.random.choice(s, 32)\n#run: make_decision(s, sc)\n#from: https://github.com/serge-sans-paille/pythran/issues/801\n\nimport numpy as np\n#pythran export make_decision(complex128[], complex128[])\ndef make_decision(E, symbols):\n    L = E.shape[0]\n    syms_out = np.zeros(L, dtype=E.dtype)\n    for i in range(L):\n        im = np.argmin(abs(E[i]-symbols)**2)\n        syms_out[i] = symbols[im]\n    return syms_out", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_make_decision", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "7d1749c0adccd050c06ccecb9975be0515c4ac5ad0bb55ca015076cfa0aefb0e", "warmup_time": -1}, "benchmarks.TimeSuite.time_mandel": {"code": "#setup: import numpy as np; image = np.zeros((512, 256), dtype = np.uint8)\n#run: mandel(-2.0, 1.0, -1.0, 1.0, image, 20)\n\n#pythran export mandel(float, float, float, float, uint8[][], int)\ndef kernel(x, y, max_iters):\n  \"\"\"\n    Given the real and imaginary parts of a complex number,\n    determine if it is a candidate for membership in the Mandelbrot\n    set given a fixed number of iterations.\n  \"\"\"\n  c = complex(x, y)\n  z = 0.0j\n  for i in range(max_iters):\n    z = z*z + c\n    if (z.real*z.real + z.imag*z.imag) >= 4:\n      return i\n\n  return max_iters\n\ndef mandel(min_x, max_x, min_y, max_y, image, iters):\n  height = image.shape[0]\n  width = image.shape[1]\n\n  pixel_size_x = (max_x - min_x) / width\n  pixel_size_y = (max_y - min_y) / height\n\n  for x in range(width):\n    real = min_x + x * pixel_size_x\n    for y in range(height):\n      imag = min_y + y * pixel_size_y\n      color = kernel(real, imag, iters)\n      image[y, x] = color", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_mandel", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "b1df0ebd5b96994ab624a76f6444009fbc1a3bae28ea36805097cd49460317fe", "warmup_time": -1}, "benchmarks.TimeSuite.time_multiple_sum": {"code": "#from http://stackoverflow.com/questions/77999777799977/numpy-vs-cython-speed\n#pythran export multiple_sum(float[][])\n#setup: import numpy as np ; r = np.random.rand(100,100)\n#run: multiple_sum(r)\nimport numpy as np\ndef multiple_sum(array):\n\n    rows = array.shape[0]\n    cols = array.shape[1]\n\n    out = np.zeros((rows, cols))\n\n    for row in range(0, rows):\n        out[row, :] = np.sum(array - array[row, :], 0)\n\n    return out", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_multiple_sum", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "15560cbe661cb8b8792ed9e9513139e95e773d04f71be7db3f4307e8f3f703b6", "warmup_time": -1}, "benchmarks.TimeSuite.time_normalize_complex_arr": {"code": "import numpy as np\n#from: https://stackoverflow.com/questions/41576536/normalizing-complex-values-in-numpy-python\n#setup: import numpy as np; np.random.seed(0); N = 10000; x = np.random.random(N) + 1j *  np.random.random(N)\n#run: normalize_complex_arr(x)\n\n#pythran export normalize_complex_arr(complex[])\n\ndef normalize_complex_arr(a):\n    a_oo = a - a.real.min() - 1j*a.imag.min() # origin offsetted\n    return a_oo/np.abs(a_oo).max()", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_normalize_complex_arr", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "239e5a298a19a5f33ebd83f97421e9ba113647522a2616387c4b292e7c0d0d3c", "warmup_time": -1}, "benchmarks.TimeSuite.time_pairwise": {"code": "#from: http://jakevdp.github.com/blog/2012/08/24/numba-vs-cython/\n#setup: import numpy as np ; X = np.linspace(0,10,20000).reshape(200,100)\n#run: pairwise(X)\n\n#pythran export pairwise(float [][])\n\nimport numpy as np\ndef pairwise(X):\n    M, N = X.shape\n    D = np.empty((M,M))\n    for i in range(M):\n        for j in range(M):\n            d = 0.0\n            for k in range(N):\n                tmp = X[i,k] - X[j,k]\n                d += tmp * tmp\n            D[i,j] = np.sqrt(d)\n    return D", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_pairwise", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "222c75264b39583b655cf80689a8f487b70b0e1de313fb3de16a6fa9c2df0c20", "warmup_time": -1}, "benchmarks.TimeSuite.time_periodic_dist": {"code": "#setup: import numpy as np ; N = 20 ; x = y = z = np.arange(0., N, 0.1) ; L = 4 ; periodic = True\n#run: periodic_dist(x, x, x, L,periodic, periodic, periodic)\n\n#pythran export periodic_dist(float [], float[], float[], int, bool, bool, bool)\nimport numpy as np \n\ndef periodic_dist(x, y, z, L, periodicX, periodicY, periodicZ):\n    \" \"\"Computes distances between all particles and places the result in a matrix such that the ij th matrix entry corresponds to the distance between particle i and j\"\" \"\n    N = len(x)\n    xtemp = np.tile(x,(N,1))\n    dx = xtemp - xtemp.T\n    ytemp = np.tile(y,(N,1))\n    dy = ytemp - ytemp.T\n    ztemp = np.tile(z,(N,1))\n    dz = ztemp - ztemp.T\n\n    # Particles 'feel' each other across the periodic boundaries\n    if periodicX:\n        dx[dx>L/2]=dx[dx > L/2]-L\n        dx[dx<-L/2]=dx[dx < -L/2]+L\n\n    if periodicY:\n        dy[dy>L/2]=dy[dy>L/2]-L\n        dy[dy<-L/2]=dy[dy<-L/2]+L\n\n    if periodicZ:\n        dz[dz>L/2]=dz[dz>L/2]-L\n        dz[dz<-L/2]=dz[dz<-L/2]+L\n\n    # Total Distances\n    d = np.sqrt(dx**2+dy**2+dz**2)\n\n    # Mark zero entries with negative 1 to avoid divergences\n    d[d==0] = -1\n\n    return d, dx, dy, dz", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_periodic_dist", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "15517c8acae5849619837ae1c83fe0f7af943a9edfa80f77d06d79baf9f924ea", "warmup_time": -1}, "benchmarks.TimeSuite.time_repeating": {"code": "#from: http://stackoverflow.com/questions/14553331/how-to-improve-numpy-performance-in-this-short-code\n#pythran export repeating(float[], int)\n#setup: import numpy as np ; a = np.random.rand(10000)\n#run: repeating(a, 20)\n\nimport numpy as np\n\ndef repeating(x, nvar_y):\n    nvar_x = x.shape[0]\n    y = np.empty(nvar_x*(1+nvar_y))\n    y[0:nvar_x] = x[0:nvar_x]\n    y[nvar_x:] = np.repeat(x,nvar_y)\n    return y", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_repeating", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "fe08e0e49033743433ef3cd171e2af27f17d73122e1e5eb450c17f7262d3524a", "warmup_time": -1}, "benchmarks.TimeSuite.time_reverse_cumsum": {"code": "#from: http://stackoverflow.com/questions/16541618/perform-a-reverse-cumulative-sum-on-a-numpy-array\n#pythran export reverse_cumsum(float[])\n#setup: import numpy as np ; r = np.random.rand(1000000)\n#run: reverse_cumsum(r)\nimport numpy as np\ndef reverse_cumsum(x):\n    return np.cumsum(x[::-1])[::-1]", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_reverse_cumsum", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "5f1f430fc4dd7295a8a52aa7ec536197a48061e8e883e1bcabf8d269d2f7fcce", "warmup_time": -1}, "benchmarks.TimeSuite.time_rosen": {"code": "#setup: import numpy as np; r = np.arange(1000000, dtype=float)\n#run: rosen(r)\nimport numpy as np\n\n#pythran export rosen(float[])\n\ndef rosen(x):\n    t0 = 100 * (x[1:] - x[:-1] ** 2) ** 2\n    t1 = (1 - x[:-1]) ** 2\n    return np.sum(t0 + t1)", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_rosen", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "c51d54e0522df936cf358e75f686a82656657442eefb38620655b873436ff219", "warmup_time": -1}, "benchmarks.TimeSuite.time_slowparts": {"code": "#from: https://groups.google.com/forum/#!topic/parakeet-python/p-flp2kdE4U\n#setup: import numpy as np ;d = 10 ;re = 5 ;params = (d, re, np.ones((2*d, d+1, re)), np.ones((d, d+1, re)),  np.ones((d, 2*d)), np.ones((d, 2*d)), np.ones((d+1, re, d)), np.ones((d+1, re, d)), 1)\n#run: slowparts(*params)\n\n#pythran export slowparts(int, int, float [][][], float [][][], float [][], float [][], float [][][], float [][][], int)\nfrom numpy import zeros, power, tanh\ndef slowparts(d, re, preDz, preWz, SRW, RSW, yxV, xyU, resid):\n    \"\"\" computes the linear algebra intensive part of the gradients of the grae\n    \"\"\"\n    fprime = lambda x: 1 - power(tanh(x), 2)\n\n    partialDU = zeros((d+1, re, 2*d, d))\n    for k in range(2*d):\n        for i in range(d):\n            partialDU[:,:,k,i] = fprime(preDz[k]) * fprime(preWz[i]) * (SRW[i,k] + RSW[i,k]) * yxV[:,:,i]\n\n    return partialDU", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_slowparts", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "28f44681259bf5fd6a791b9b402c63bdcbbd4f7aba83a6dc91a9032b1534e339", "warmup_time": -1}, "benchmarks.TimeSuite.time_smoothing": {"code": "#setup: import numpy as np ; N = 10e-7 ; a = np.arange(0,1,N)\n#run: smoothing(a, .4)\n#from: http://www.parakeetpython.com/\n\n#pythran export smoothing(float[], float)\n\ndef smoothing(x, alpha):\n  \"\"\"\n  Exponential smoothing of a time series\n  For x = 10**6 floats\n  - Python runtime: 9 seconds\n  - Parakeet runtime: .01 seconds\n  \"\"\"\n  s = x.copy()\n  for i in range(1, len(x)):\n    s[i] = alpha * x[i] + (1 - alpha) * s[i-1]\n  return s", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_smoothing", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "b3d17973f67862044783fde65f438b749f5e4a78ca4957f6cc774cc34e82a167", "warmup_time": -1}, "benchmarks.TimeSuite.time_specialconvolve": {"code": "#from: http://stackoverflow.com/questions/2196693/improving-numpy-performance\n#pythran export specialconvolve(uint32 [][])\n#setup: import numpy as np ; r = np.arange(100*10000, dtype=np.uint32).reshape(1000,1000)\n#run: specialconvolve(r)\n\ndef specialconvolve(a):\n    # sorry, you must pad the input yourself\n    rowconvol = a[1:-1,:] + a[:-2,:] + a[2:,:]\n    colconvol = rowconvol[:,1:-1] + rowconvol[:,:-2] + rowconvol[:,2:] - 9*a[1:-1,1:-1]\n    return colconvol", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_specialconvolve", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "bdcfd39ff19144b341bf9a94fef0a9ab0f303852b81527f75dea311a564071d4", "warmup_time": -1}, "benchmarks.TimeSuite.time_vibr_energy": {"code": "#from: http://stackoverflow.com/questions/17112550/python-and-numba-for-vectorized-functions\n#setup: import numpy as np ; N = 100000 ; a, b, c = np.random.rand(N), np.random.rand(N), np.random.rand(N)\n#run: vibr_energy(a, b, c)\n\n#pythran export vibr_energy(float64[], float64[], float64[])\nimport numpy\ndef vibr_energy(harmonic, anharmonic, i):\n    return numpy.exp(-harmonic * i - anharmonic * (i ** 2))", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_vibr_energy", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "6d2d53664a8266b0753a913422a069c4f2c675bf830421eae661f5777d65cc61", "warmup_time": -1}, "benchmarks.TimeSuite.time_wave": {"code": "#from https://github.com/sklam/numba-example-wavephysics\n#setup: N=4000\n#run: wave(N)\nimport numpy as np\nfrom math import ceil\n\ndef physics(masspoints, dt, plunk, which):\n  ppos = masspoints[1]\n  cpos = masspoints[0]\n  N = cpos.shape[0]\n  # apply hooke's law\n  HOOKE_K = 2100000.\n  DAMPING = 0.0001\n  MASS = .01\n\n  force = np.zeros((N, 2))\n  for i in range(1, N):\n    dx, dy = cpos[i] - cpos[i - 1]\n    dist = np.sqrt(dx**2 + dy**2)\n    assert dist != 0\n    fmag = -HOOKE_K * dist\n    cosine = dx / dist\n    sine = dy / dist\n    fvec = np.array([fmag * cosine, fmag * sine])\n    force[i - 1] -= fvec\n    force[i] += fvec\n\n  force[0] = force[-1] = 0, 0\n  force[which][1] += plunk\n  accel = force / MASS\n\n  # verlet integration\n  npos = (2 - DAMPING) * cpos - (1 - DAMPING) * ppos + accel * (dt**2)\n\n  masspoints[1] = cpos\n  masspoints[0] = npos\n\n#pythran export wave(int)\ndef wave(PARTICLE_COUNT):\n    SUBDIVISION = 300\n    FRAMERATE = 60\n    count = PARTICLE_COUNT\n    width, height = 1200, 400\n\n    masspoints = np.empty((2, count, 2), np.float64)\n    initpos = np.zeros(count, np.float64)\n    for i in range(1, count):\n        initpos[i] = initpos[i - 1] + float(width) / count\n    masspoints[:, :, 0] = initpos\n    masspoints[:, :, 1] = height / 2\n    f = 15\n    plunk_pos = count // 2\n    physics( masspoints, 1./ (SUBDIVISION * FRAMERATE), f, plunk_pos)\n    return masspoints[0, count // 2]", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_wave", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "0865c95eca84633f6c1345ff6354daa1d52d8359788dc290f2665aad2e8b02a9", "warmup_time": -1}, "benchmarks.TimeSuite.time_wdist": {"code": "#from: http://stackoverflow.com/questions/19277244/fast-weighted-euclidean-distance-between-points-in-arrays/19277334#19277334\n#setup: import numpy as np ; N = 70 ; A = np.random.rand(N,N) ; B =  np.random.rand(N,N) ; W = np.random.rand(N,N)\n#run: wdist(A,B,W)\n\n#pythran export wdist(float64 [][], float64 [][], float64[][])\n\nimport numpy as np\ndef wdist(A, B, W):\n\n    k,m = A.shape\n    _,n = B.shape\n    D = np.zeros((m, n))\n\n    for ii in range(m):\n        for jj in range(n):\n            wdiff = (A[:,ii] - B[:,jj]) / W[:,ii]\n            D[ii,jj] = np.sqrt((wdiff**2).sum())\n    return D", "min_run_count": 2, "name": "benchmarks.TimeSuite.time_wdist", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "setup_cache_key": "/home/sguelton/sources/pythran-asv/benchmarks/benchmarks.py:29", "timeout": 100000000.0, "type": "time", "unit": "seconds", "version": "3d378ea440c0b2b889ee5de1c7f51a99fe3373c0837bd3cbac60d28b098f77b6", "warmup_time": -1}}, "machines": {"ssp": {"arch": "x86_64", "cpu": "Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz", "machine": "ssp", "os": "Linux 3.10.0-891.el7.x86_64", "ram": "15908200", "version": 1}}, "tags": {"0.8.2": 3517, "0.8.3": 3541, "0.8.4": 3663, "0.8.4post0": 3669, "0.8.5": 3783, "0.8.6": 3888, "0.8.7": 4056, "0.9.0": 4174, "0.9.1": 4444, "0.9.1post0": 4457}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}